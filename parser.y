%{
#include <cstdio>
#include <iostream>
#include <vector>
#include "errtoken.c"
using namespace std;

extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
extern int line_num;
 
void yyerror(const char *s);

arbolSintactico *raiz;
vector<errToken> errores;

%}

%union{
	int num;
	string str;
	char carac;
}

%output  "parser.c"
%defines "parser.h"

%locations

%token <num> NUM
%token <str> ID
%token <carac> CARACTER
%token <str> OPER




%left	TOKEN_MENORIG TOKEN_MAYORIG
%left	TOKEN_MENOR TOKEN_MAYOR
%left	TOKEN_IGUAL TOKEN_DESIGUAL
%left	TOKEN_SUMA TOKEN_RESTA
%left	TOKEN_MULT TOKEN_DIV TOKEN_MOD
%left	TOKEN_DISY
%left	TOKEN_CONJ
%right	TOKEN_NEG	



%%

PROGRAMA: CREATE EXECUTE {root = arbolSintactico($1,$2)}
	| CREATE
	| EXECUTE
	| ERROR
	;

CREATE: TOKEN_CREATE SECUENCIA_DECLAR
	;

SECUENCIA_DECLAR: SECUENCIA_DECLAR DECLARATION
	| DECLARATION 
	;

DECLARATION: TYPE TOKEN_BOT LISTA_IDS SECUENCIA_COMPORT TOKEN_END
	;

TYPE: TOKEN_BOOL
	| TOKEN_CHAR
	| TOKEN_INT
	;

SECUENCIA_COMPORT: SECUENCIA_COMPORT COMPORTAMIENTO
	| COMPORTAMIENTO
	;

COMPORTAMIENTO: TOKEN_ON CONDITION

EXECUTE: TOKEN_EXECUTE SECUENCIA_INSTRUC { $$ = $1 }

SECUENCIA_INSTRUC: INSTRUCCION {$$ = secuenciaInstrucciones($1);}
	| SECUENCIA_INSTRUC TOKEN_COMA INSTRUCCION {$$ = secuenciaInstrucciones($1,$2);}
	;

INSTRUCCION: ADVANCE
	| ACTIVATE
	| DEACTIVATE
	| CONDICIONAL
	| LOOP
	| INCORPALCANCE
	;

CONDICIONAL: TOKEN_IF BOOLEXPRESSION TOKEN_DOSPUNT  SECUENCIA_INSTRUC ELSE TOKEN_END
	| TOKEN_IF BOOLEXPRESSION TOKEN_DOSPUNT ELSE TOKEN_END
	;

ELSE: TOKEN_ELSE TOKEN_DOSPUNT SECUENCIA_INSTRUC
	|
	;

ACTIVATE: TOKEN_ACTIVATE LISTA_IDS TOKEN_PUNTO
	;

ADVANCE: TOKEN_ADVANCE LISTA_IDS TOKEN_PUNTO
	;

DEACTIVATE: TOKEN_DEACTIVATE LISTA_IDS TOKEN_PUNTO
	;

LOOP: TOKEN_WHILE BOOLEXPRESSION TOKEN_DOSPUNT SECUENCIA_INSTRUC TOKEN_END
	;

INCORPALCANCE: CREATE EXECUTE
	;

LISTA_IDS: ID
	| LISTA_IDS TOKEN_COMA ID
	;

BOOLEXPRESSION: TOKEN_PARABRE BOOLEXPRESSION TOKEN_PARCIERRA
	| TOKEN_NEG BOOLEXPRESSION
	| BOOLEXPRESSION TOKEN_CONJ BOOLVALUE
	| BOOLEXPRESSION TOKEN_DISY BOOLVALUE
	| BOOLEXPRESSION TOKEN_IGUAL BOOLVALUE
	| BOOLEXPRESSION TOKEN_DESIGUAL BOOLVALUE
	| ALGEXPRESSION TOKEN_MENOR NUMVALUE
	| ALGEXPRESSION TOKEN_MAYOR NUMVALUE
	| ALGEXPRESSION TOKEN_MENORIG NUMVALUE
	| ALGEXPRESSION TOKEN_MAYORIG NUMVALUE
	| ALGEXPRESSION TOKEN_IGUAL NUMVALUE
	| ALGEXPRESSION TOKEN_DESIGUAL NUMVALUE
	| BOOLVALUE
	;

ALGEXPRESSION: ALGEXPRESSION BINARYOPERATION NUMVALUE
	| UNARYOPERATION ALGEXPRESSION
	| TOKEN_PARABRE ALGEXPRESSION TOKEN_PARCIERRA
	| NUMVALUE
	;

BINARYOPERATION: TOKEN_MULT
	| TOKEN_SUMA
	| TOKEN_RESTA
	| TOKEN_DIV
	| TOKEN_MOD
	;

UNARYOPERATION: TOKEN_RESTA
	;

BOOLVALUE: TOKEN_TRUE
	| TOKEN_FALSE
	| ID
	;


NUMVALUE: NUM
	| ID
	;


%%

int yyerror(string s){
	extern int yylineno;	// defined and maintained in lex.c
	extern char *yytext;	// defined and maintained in lex.c

	cerr << "ERROR: " << s << " at symbol \"" << yytext;
	cerr << "\" on line " << yylineno << endl;
	exit(1);
}

int yyerror(char *s){
	printf("Error: %s",s);
	return 0;
}